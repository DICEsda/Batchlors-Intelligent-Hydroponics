# Bug Fixes (#68, #74, #76, #77) Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix four bugs: broken pump alert tests (#68), frontend memory leaks (#74), firmware millis() overflow (#76), and firmware raw pointer leaks (#77).

**Architecture:** Four independent bug fixes across backend (C#), frontend (Angular/TypeScript), and firmware (C++ ESP32). Each can be committed separately.

**Tech Stack:** C# / NSubstitute / xUnit, Angular 19 / RxJS / takeUntilDestroyed, C++11 / Arduino / ESP32

---

## Task 1: Fix broken pump alert unit tests (#68)

**Files:**
- Modify: `Backend/tests/IoT.Backend.UnitTests/Services/AlertServiceTests.cs:349-380`

The production code was already fixed (pump_failure alert creation removed, replaced with unconditional auto-resolve). But two tests still assert the old buggy behavior.

**Step 1: Replace test `PumpOff_CreatesCriticalPumpFailureAlert`**

The old test (lines 349-364) asserts that `mainPumpOn: false` creates a `pump_failure` alert. The current code never creates pump_failure alerts — it always auto-resolves. Replace it with a test that verifies no pump_failure alert is created when pump is off.

```csharp
[Fact]
public async Task CheckCoordinatorAlertsAsync_PumpOff_DoesNotCreatePumpFailureAlert()
{
    // Arrange — pump is off (normal scheduled operation)
    var coord = MakeCoordinator(mainPumpOn: false);

    // Act
    await _sut.CheckCoordinatorAlertsAsync(coord);

    // Assert — pump_failure alert creation was disabled (issue #68)
    await _alertRepo.DidNotReceive().UpsertAsync(
        Arg.Is<Alert>(a => a.Category == "pump_failure"),
        Arg.Any<CancellationToken>());
}
```

**Step 2: Replace test `PumpOn_AutoResolvesPumpFailureAlert`**

The old test (lines 366-380) asserts that `mainPumpOn: true` auto-resolves pump_failure. The current code always auto-resolves regardless of pump state. Replace with a test that verifies auto-resolve always happens.

```csharp
[Fact]
public async Task CheckCoordinatorAlertsAsync_AlwaysAutoResolvesPumpFailureAlert()
{
    // Arrange — existing pump_failure alert from old logic
    var coord = MakeCoordinator(mainPumpOn: false);
    var existingAlert = MakeActiveAlert("farm-1:coord-1:pump_failure");
    _alertRepo.GetActiveAlertByKeyAsync("farm-1:coord-1:pump_failure", Arg.Any<CancellationToken>())
        .Returns(existingAlert);

    // Act
    await _sut.CheckCoordinatorAlertsAsync(coord);

    // Assert — stale pump_failure alerts are always auto-resolved
    await _alertRepo.Received().ResolveAsync("alert-123", Arg.Any<CancellationToken>());
}
```

**Step 3: Run tests to verify they pass**

Run: `dotnet test Backend/tests/IoT.Backend.UnitTests/ --filter "FullyQualifiedName~Pump"`
Expected: All 3 pump-related tests pass (the two new ones + `MainPumpNull_SkipsPumpCheck`)

**Step 4: Commit**

```bash
git add Backend/tests/IoT.Backend.UnitTests/Services/AlertServiceTests.cs
git commit -m "fix(backend): align pump alert tests with #68 fix — pump OFF is normal operation"
```

---

## Task 2: Fix frontend memory leak in towers-list.component.ts (#74)

**Files:**
- Modify: `Frontend/IOT-Frontend-main/src/app/pages/towers-list/towers-list.component.ts:1,93,144-152`

**Step 1: Add `DestroyRef` import and `takeUntilDestroyed`**

Add `DestroyRef` to imports from `@angular/core` and `takeUntilDestroyed` from `@angular/core/rxjs-interop`. Inject `DestroyRef` and pipe `route.queryParams` through `takeUntilDestroyed()`.

Change imports (line 1 area) to include:
```typescript
import { ..., inject, DestroyRef } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
```

Change class declaration from:
```typescript
export class TowersListComponent implements OnInit {
```
to:
```typescript
export class TowersListComponent implements OnInit {
  private readonly destroyRef = inject(DestroyRef);
```

Change `ngOnInit` from:
```typescript
this.route.queryParams.subscribe(params => {
```
to:
```typescript
this.route.queryParams.pipe(
  takeUntilDestroyed(this.destroyRef)
).subscribe(params => {
```

**Step 2: Build to verify**

Run: `npx ng build` (from Frontend/IOT-Frontend-main/)
Expected: No compilation errors

**Step 3: Commit**

```bash
git add Frontend/IOT-Frontend-main/src/app/pages/towers-list/towers-list.component.ts
git commit -m "fix(frontend): add takeUntilDestroyed to towers-list queryParams subscription (#74)"
```

---

## Task 3: Fix frontend memory leak in header.component.ts (#74)

**Files:**
- Modify: `Frontend/IOT-Frontend-main/src/app/components/layout/header/header.component.ts:122-129`

The `searchSubject.pipe().subscribe()` result is not pushed to the `subscriptions[]` array. Fix by pushing it.

**Step 1: Push search subscription to subscriptions array**

Change from:
```typescript
constructor() {
    // Setup debounced search
    this.searchSubject.pipe(
      debounceTime(300),
      distinctUntilChanged()
    ).subscribe(query => {
      this.performSearch(query);
    });
```

to:
```typescript
constructor() {
    // Setup debounced search
    this.subscriptions.push(
      this.searchSubject.pipe(
        debounceTime(300),
        distinctUntilChanged()
      ).subscribe(query => {
        this.performSearch(query);
      })
    );
```

**Step 2: Build to verify**

Run: `npx ng build` (from Frontend/IOT-Frontend-main/)
Expected: No compilation errors

**Step 3: Commit**

```bash
git add Frontend/IOT-Frontend-main/src/app/components/layout/header/header.component.ts
git commit -m "fix(frontend): push search subscription to cleanup array in header (#74)"
```

---

## Task 4: Fix frontend auto-refresh stacking in iot-data.service.ts (#74)

**Files:**
- Modify: `Frontend/IOT-Frontend-main/src/app/core/services/iot-data.service.ts:36,440-472`

The `destroy$` Subject pattern is fragile: calling `stopAutoRefresh()` then `startAutoRefresh()` again won't work because the Subject already emitted. Fix by using a dedicated `Subscription` that gets unsubscribed on each start/stop.

**Step 1: Add a private autoRefreshSub field and guard against multiple starts**

Add after `private readonly destroy$ = new Subject<void>();` (line 36):
```typescript
private autoRefreshSub: Subscription | null = null;
```

Add the `Subscription` import if not already present.

**Step 2: Rewrite startAutoRefresh/stopAutoRefresh**

Change `startAutoRefresh()` to:
```typescript
startAutoRefresh(): void {
    // Prevent multiple subscriptions stacking
    this.stopAutoRefresh();

    this.autoRefreshSub = this.refreshInterval$.pipe(
      switchMap(() => this.api.getCoordinators()),
      tap(data => {
        if (Array.isArray(data)) {
          this.coordinators.set(data);
        }
      }),
      switchMap(() => this.api.getNodes()),
      tap(data => this.nodes.set(data)),
      switchMap(() => this.api.getAlerts({ page: 1, pageSize: 50 })),
      tap((data: any) => {
        if (Array.isArray(data)) {
          this.alerts.set(data);
        } else {
          const alerts = data.items ?? data.data ?? [];
          this.alerts.set(Array.isArray(alerts) ? alerts : []);
        }
      }),
      catchError(err => {
        console.error('Auto-refresh failed:', err);
        return of(null);
      })
    ).subscribe();
}
```

Change `stopAutoRefresh()` to:
```typescript
stopAutoRefresh(): void {
    this.autoRefreshSub?.unsubscribe();
    this.autoRefreshSub = null;
}
```

Keep the `destroy$` Subject for the existing `ngOnDestroy`:
```typescript
ngOnDestroy(): void {
    this.stopAutoRefresh();
    this.destroy$.next();
    this.destroy$.complete();
}
```

**Step 3: Build to verify**

Run: `npx ng build` (from Frontend/IOT-Frontend-main/)
Expected: No compilation errors

**Step 4: Commit**

```bash
git add Frontend/IOT-Frontend-main/src/app/core/services/iot-data.service.ts
git commit -m "fix(frontend): prevent auto-refresh subscription stacking in IoTDataService (#74)"
```

---

## Task 5: Fix frontend diagnostics.service.ts error handling (#74)

**Files:**
- Modify: `Frontend/IOT-Frontend-main/src/app/core/services/diagnostics.service.ts:55-62`

Root singleton — subscription lives for app lifetime so no takeUntil needed. But add error handling for resilience.

**Step 1: Add error callback to WebSocket subscription**

Change from:
```typescript
constructor() {
    // Subscribe to the general message stream from WebSocket
    this.ws.messages$.subscribe(msg => {
      if (msg.type === 'diagnostics_update') {
        const snapshot = msg.payload as SystemMetricsSnapshot;
        this.onSnapshot(snapshot);
      }
    });
}
```

to:
```typescript
constructor() {
    // Subscribe to the general message stream from WebSocket
    this.ws.messages$.subscribe({
      next: (msg) => {
        if (msg.type === 'diagnostics_update') {
          const snapshot = msg.payload as SystemMetricsSnapshot;
          this.onSnapshot(snapshot);
        }
      },
      error: (err) => console.error('DiagnosticsService: WebSocket stream error', err),
    });
}
```

**Step 2: Build to verify**

Run: `npx ng build` (from Frontend/IOT-Frontend-main/)
Expected: No compilation errors

**Step 3: Commit**

```bash
git add Frontend/IOT-Frontend-main/src/app/core/services/diagnostics.service.ts
git commit -m "fix(frontend): add error handler to diagnostics WebSocket subscription (#74)"
```

---

## Task 6: Fix frontend settings.component.ts dead import (#74)

**Files:**
- Modify: `Frontend/IOT-Frontend-main/src/app/pages/settings/settings.component.ts:1`

**Step 1: Remove unused `OnDestroy` import**

Change line 1 from:
```typescript
import { Component, signal, computed, OnInit, OnDestroy, inject } from '@angular/core';
```
to:
```typescript
import { Component, signal, computed, OnInit, inject } from '@angular/core';
```

**Step 2: Build to verify**

Run: `npx ng build` (from Frontend/IOT-Frontend-main/)
Expected: No compilation errors

**Step 3: Commit**

```bash
git add Frontend/IOT-Frontend-main/src/app/pages/settings/settings.component.ts
git commit -m "fix(frontend): remove unused OnDestroy import from settings component (#74)"
```

---

## Task 7: Fix frontend farm-overview.component.ts error callback (#74)

**Files:**
- Modify: `Frontend/IOT-Frontend-main/src/app/pages/farm-overview/farm-overview.component.ts:256-283`

Subscription IS correctly tracked in `telemetrySubs`. The issue is no error callback.

**Step 1: Add error callback to reservoir telemetry subscription**

Change from:
```typescript
const sub = this.wsService.reservoirTelemetry$.subscribe((t: ReservoirTelemetry) => {
```

to:
```typescript
const sub = this.wsService.reservoirTelemetry$.subscribe({
  next: (t: ReservoirTelemetry) => {
```

And close with error handler after the existing closing `});`:
```typescript
  },
  error: (err) => console.error('FarmOverview: reservoir telemetry stream error', err),
});
```

The full rewrite of the subscribe block:
```typescript
const sub = this.wsService.reservoirTelemetry$.subscribe({
  next: (t: ReservoirTelemetry) => {
    // Accumulate values
    if (t.ph != null) { this.phAccum.sum += t.ph; this.phAccum.count++; }
    if (t.ec != null) { this.ecAccum.sum += t.ec; this.ecAccum.count++; }
    if (t.waterLevel != null) { this.waterLevelAccum.sum += t.waterLevel; this.waterLevelAccum.count++; }

    // Emit aggregated point every AGG_INTERVAL_MS
    const now = Date.now();
    if (now - this.lastAggTimestamp >= this.AGG_INTERVAL_MS) {
      this.lastAggTimestamp = now;
      const time = new Date(now);

      if (this.phAccum.count > 0) {
        this.avgPhChart?.appendPoint({ time, value: +(this.phAccum.sum / this.phAccum.count).toFixed(2) });
        this.phAccum = { sum: 0, count: 0 };
      }
      if (this.ecAccum.count > 0) {
        this.avgEcChart?.appendPoint({ time, value: +(this.ecAccum.sum / this.ecAccum.count).toFixed(2) });
        this.ecAccum = { sum: 0, count: 0 };
      }
      if (this.waterLevelAccum.count > 0) {
        this.avgWaterLevelChart?.appendPoint({ time, value: +(this.waterLevelAccum.sum / this.waterLevelAccum.count).toFixed(1) });
        this.waterLevelAccum = { sum: 0, count: 0 };
      }
    }
  },
  error: (err) => console.error('FarmOverview: reservoir telemetry stream error', err),
});
```

**Step 2: Build to verify**

Run: `npx ng build` (from Frontend/IOT-Frontend-main/)
Expected: No compilation errors

**Step 3: Commit**

```bash
git add Frontend/IOT-Frontend-main/src/app/pages/farm-overview/farm-overview.component.ts
git commit -m "fix(frontend): add error handler to reservoir telemetry subscription (#74)"
```

---

## Task 8: Create SafeTimer utility for firmware (#76)

**Files:**
- Create: `Firmware/shared/src/utils/SafeTimer.h`

Create a lightweight header-only utility that wraps the safe `millis()` subtraction pattern.

**Step 1: Create the SafeTimer header**

```cpp
#pragma once

#include <Arduino.h>

/**
 * Deadline-based timer that handles millis() overflow correctly.
 * 
 * The standard pattern `deadline = millis() + duration` overflows after ~49.7 days.
 * This class uses subtraction: `(millis() - startTime) >= duration` which is
 * overflow-safe due to unsigned integer arithmetic.
 * 
 * Usage:
 *   Deadline timer;
 *   timer.set(5000);             // 5 second deadline
 *   if (timer.expired()) { ... } // true after 5 seconds
 *   timer.clear();               // disable the deadline
 */
class Deadline {
public:
    Deadline() : startMs_(0), durationMs_(0), active_(false) {}

    /** Start a deadline that expires after durationMs milliseconds from now. */
    void set(uint32_t durationMs) {
        startMs_ = millis();
        durationMs_ = durationMs;
        active_ = true;
    }

    /** Returns true if the deadline has expired. Returns false if inactive. */
    bool expired() const {
        if (!active_) return false;
        return (uint32_t)(millis() - startMs_) >= durationMs_;
    }

    /** Returns true if the deadline is active and has NOT expired yet. */
    bool running() const {
        return active_ && !expired();
    }

    /** Deactivate the deadline. expired() will return false. */
    void clear() {
        active_ = false;
    }

    /** Returns true if a deadline has been set (may or may not be expired). */
    bool isActive() const { return active_; }

private:
    uint32_t startMs_;
    uint32_t durationMs_;
    bool active_;
};
```

**Step 2: Commit**

```bash
git add Firmware/shared/src/utils/SafeTimer.h
git commit -m "feat(firmware): add Deadline utility for overflow-safe millis() timing (#76)"
```

---

## Task 9: Fix millis() overflow in StatusLed.h (#76)

**Files:**
- Modify: `Firmware/coordinator/src/utils/StatusLed.h`

**Step 1: Replace millis() + durationMs pattern with Deadline**

Add include at top:
```cpp
#include "../../shared/src/utils/SafeTimer.h"
```
Note: verify the relative path works. It may need to be `#include "../../../shared/src/utils/SafeTimer.h"` depending on include paths in platformio.ini.

Replace `pulseEnd` member (line 85) with `Deadline pulseDl;`.

Change `pulse()` (line 20-24) from:
```cpp
pulseEnd = millis() + durationMs;
```
to:
```cpp
pulseDl.set(durationMs);
```

Change `loop()` (line 29) from:
```cpp
if (active && now >= pulseEnd) {
```
to:
```cpp
if (active && pulseDl.expired()) {
```

Remove the `uint32_t now = millis();` line from loop() only if no other code in that method uses `now` — but the breathing math at line 35 uses `now`, so keep it.

Remove the `uint32_t pulseEnd = 0;` member.

**Step 2: Verify firmware compiles**

Run: `pio run -e coordinator` (from Firmware/coordinator/)
Expected: Compiles without errors

**Step 3: Commit**

```bash
git add Firmware/coordinator/src/utils/StatusLed.h
git commit -m "fix(firmware): use Deadline for overflow-safe pulse timing in StatusLed (#76)"
```

---

## Task 10: Fix millis() overflow in LedController.cpp (#76)

**Files:**
- Modify: `Firmware/coordinator/src/core/LedController.cpp`
- Modify: `Firmware/coordinator/src/core/LedController.h` (add Deadline members)

**Step 1: Update LedController to use Deadline**

In `LedController.h`, replace:
- `std::vector<uint32_t> groupFlashUntilMs_` with `std::vector<Deadline> groupFlashDl_`
- `uint32_t manualTimeoutMs_` with `Deadline manualTimeoutDl_`

Add include: `#include "../../shared/src/utils/SafeTimer.h"`

In `LedController.cpp`:

Change `begin()`:
```cpp
groupFlashUntilMs_.assign(groupCount_, 0);
```
to:
```cpp
groupFlashDl_.assign(groupCount_, Deadline());
```

Change `rebuildMapping()`:
```cpp
std::fill(groupFlashUntilMs_.begin(), groupFlashUntilMs_.end(), 0);
```
to:
```cpp
for (auto& dl : groupFlashDl_) dl.clear();
```

Change `flash()` (line 84):
```cpp
groupFlashUntilMs_[idx] = millis() + durationMs;
```
to:
```cpp
groupFlashDl_[idx].set(durationMs);
```

Change `setManualMode()` (line 93):
```cpp
manualTimeoutMs_ = (timeoutMs > 0) ? (millis() + timeoutMs) : 0;
```
to:
```cpp
if (timeoutMs > 0) { manualTimeoutDl_.set(timeoutMs); } else { manualTimeoutDl_.clear(); }
```

Change `update()` (line 104):
```cpp
if (manualMode_ && manualTimeoutMs_ > 0 && now > manualTimeoutMs_) {
```
to:
```cpp
if (manualMode_ && manualTimeoutDl_.expired()) {
```

Change line 117:
```cpp
} else if (groupFlashUntilMs_[g] > now) {
```
to:
```cpp
} else if (groupFlashDl_[g].running()) {
```

**Step 2: Verify firmware compiles**

Run: `pio run -e coordinator` (from Firmware/coordinator/)
Expected: Compiles without errors

**Step 3: Commit**

```bash
git add Firmware/coordinator/src/core/LedController.cpp Firmware/coordinator/src/core/LedController.h
git commit -m "fix(firmware): use Deadline for overflow-safe timing in LedController (#76)"
```

---

## Task 11: Fix millis() overflow in TowerRegistry.cpp and NodeRegistry.cpp (#76)

**Files:**
- Modify: `Firmware/coordinator/src/towers/TowerRegistry.cpp`
- Modify: `Firmware/coordinator/src/towers/TowerRegistry.h`
- Modify: `Firmware/coordinator/src/nodes/NodeRegistry.cpp`
- Modify: `Firmware/coordinator/src/nodes/NodeRegistry.h`

Both are nearly identical. In each:

**Step 1: Replace pairingEndTime with Deadline in headers**

Add `#include "../../shared/src/utils/SafeTimer.h"` and replace `uint32_t pairingEndTime = 0;` with `Deadline pairingDl;`.

**Step 2: Update TowerRegistry.cpp**

`startPairing()` (line 97): `pairingEndTime = millis() + durationMs;` → `pairingDl.set(durationMs);`

`stopPairing()`: add `pairingDl.clear();`

`loop()` (line 33): `if (pairingActive && now >= pairingEndTime)` → `if (pairingActive && pairingDl.expired())`

`isPairingActive()` (line 111): `return pairingActive && millis() < pairingEndTime;` → `return pairingActive && pairingDl.running();`

**Step 3: Update NodeRegistry.cpp identically**

Same changes as TowerRegistry but for `NodeRegistry`.

**Step 4: Verify firmware compiles**

Run: `pio run -e coordinator` (from Firmware/coordinator/)

**Step 5: Commit**

```bash
git add Firmware/coordinator/src/towers/ Firmware/coordinator/src/nodes/
git commit -m "fix(firmware): use Deadline for overflow-safe pairing timeout in registries (#76)"
```

---

## Task 12: Fix millis() overflow in EspNow.cpp (#76)

**Files:**
- Modify: `Firmware/coordinator/src/comm/EspNow.cpp`
- Modify: `Firmware/coordinator/src/comm/EspNow.h`

**Step 1: Replace pairingEndTime with Deadline in EspNow.h**

Add `#include "../../shared/src/utils/SafeTimer.h"` and replace `uint32_t pairingEndTime = 0;` with `Deadline pairingDl;`.

**Step 2: Update EspNow.cpp**

`enablePairingMode()` (line 428): `pairingEndTime = millis() + durationMs;` → `pairingDl.set(durationMs);`

`disablePairingMode()`: add `pairingDl.clear();`

`isPairingEnabled()` (line 436): `return pairingEnabled && millis() < pairingEndTime;` → `return pairingEnabled && pairingDl.running();`

`loop()` (line 353): `if (pairingEnabled && now > pairingEndTime)` → `if (pairingEnabled && pairingDl.expired())`

**Step 3: Verify firmware compiles, commit**

```bash
git add Firmware/coordinator/src/comm/
git commit -m "fix(firmware): use Deadline for overflow-safe pairing in EspNow (#76)"
```

---

## Task 13: Fix millis() overflow in Coordinator.cpp (#76)

**Files:**
- Modify: `Firmware/coordinator/src/core/Coordinator.cpp`
- Modify: `Firmware/coordinator/src/core/Coordinator.h`

**Step 1: Replace pairingEndTime with Deadline**

In `Coordinator.h`, replace `uint32_t pairingEndTime = 0;` with `Deadline pairingDl;` and add the include.

**Step 2: Update Coordinator.cpp**

`startPairing()` (line 456): `pairingEndTime = millis() + durationMs;` → `pairingDl.set(durationMs);`

`stopPairing()`: add `pairingDl.clear();`

`loop()` (line 196): `if (pairingActive && now >= pairingEndTime)` → `if (pairingActive && pairingDl.expired())`

**Step 3: Verify firmware compiles, commit**

```bash
git add Firmware/coordinator/src/core/Coordinator.cpp Firmware/coordinator/src/core/Coordinator.h
git commit -m "fix(firmware): use Deadline for overflow-safe pairing in Coordinator (#76)"
```

---

## Task 14: Fix millis() overflow in PairingStateMachine.cpp (#76)

**Files:**
- Modify: `Firmware/coordinator/src/pairing/PairingStateMachine.cpp`
- Modify: `Firmware/coordinator/src/pairing/PairingStateMachine.h`

**Step 1: Replace permitJoinEndMs with Deadline**

In header, replace `uint32_t permitJoinEndMs = 0;` with `Deadline permitJoinDl;`.

**Step 2: Update PairingStateMachine.cpp**

`enablePermitJoin()` (line 82): `permitJoinEndMs = millis() + duration_ms;` → `permitJoinDl.set(duration_ms);`

`disablePermitJoin()`: add `permitJoinDl.clear();`

`completeBinding()` (line 449): `if (millis() < permitJoinEndMs)` → `if (permitJoinDl.running())`

**Step 3: Verify firmware compiles, commit**

```bash
git add Firmware/coordinator/src/pairing/
git commit -m "fix(firmware): use Deadline for overflow-safe permit-join in PairingStateMachine (#76)"
```

---

## Task 15: Fix millis() overflow in Reservoir.cpp (#76)

**Files:**
- Modify: `Firmware/coordinator/src/core/Reservoir.cpp`
- Modify: `Firmware/coordinator/src/core/Reservoir.h`

**Step 1: Replace groupFlashUntilMs and manualLedTimeoutMs with Deadline**

In `Reservoir.h`:
- Replace `std::array<uint32_t, N> groupFlashUntilMs` → `std::array<Deadline, N> groupFlashDl` (check actual array type)
- Replace `uint32_t manualLedTimeoutMs = 0;` → `Deadline manualLedTimeoutDl;`

**Step 2: Update Reservoir.cpp**

`flashLedForTower()` (line 689): `groupFlashUntilMs[idx] = millis() + durationMs;` → `groupFlashDl[idx].set(durationMs);`

`handleMqttCommand()` led.set (line 939): `manualLedTimeoutMs = millis() + duration;` → `if (duration > 0) { manualLedTimeoutDl.set(duration); } else { manualLedTimeoutDl.clear(); }`

`updateLeds()` (line 696): `if (manualLedMode && manualLedTimeoutMs > 0 && now > manualLedTimeoutMs)` → `if (manualLedMode && manualLedTimeoutDl.expired())`

`updateLeds()` (line 710): `if (groupFlashUntilMs[g] > now)` → `if (groupFlashDl[g].running())`

`rebuildLedMappingFromRegistry()` (line 644): `std::fill(groupFlashUntilMs.begin(), groupFlashUntilMs.end(), 0);` → `for (auto& dl : groupFlashDl) dl.clear();`

**Step 3: Verify firmware compiles, commit**

```bash
git add Firmware/coordinator/src/core/Reservoir.cpp Firmware/coordinator/src/core/Reservoir.h
git commit -m "fix(firmware): use Deadline for overflow-safe LED timing in Reservoir (#76)"
```

---

## Task 16: Fix millis() overflow in node/src/main.cpp (#76)

**Files:**
- Modify: `Firmware/node/src/main.cpp`

**Step 1: Add Deadline for statusOverrideUntilMs**

Add include: `#include "../../shared/src/utils/SafeTimer.h"` (verify path relative to node/src/).

Replace `uint32_t statusOverrideUntilMs = 0;` with `Deadline statusOverrideDl;`.

**Step 2: Update usages**

Line 859: `statusOverrideUntilMs = millis() + (setLight->ttl_ms > 0 ? setLight->ttl_ms : 10000);`
→ `statusOverrideDl.set(setLight->ttl_ms > 0 ? setLight->ttl_ms : 10000);`

Line 932: `if (statusOverrideActive && millis() > statusOverrideUntilMs)`
→ `if (statusOverrideActive && statusOverrideDl.expired())`

**Step 3: Verify node firmware compiles**

Run: `pio run -e node` (from Firmware/node/)

**Step 4: Commit**

```bash
git add Firmware/node/src/main.cpp
git commit -m "fix(firmware): use Deadline for overflow-safe status override in node (#76)"
```

---

## Task 17: Fix raw pointer leaks in Reservoir::handleTowerMessage (#77)

**Files:**
- Modify: `Firmware/coordinator/src/core/Reservoir.cpp:506-636`

There are 3 `createMessage()` calls where `delete msg` is inside the inner `if` block. If the type doesn't match, the pointer leaks.

**Step 1: Fix NODE_STATUS block (lines 511-530)**

Change from:
```cpp
EspNowMessage* msg = MessageFactory::createMessage(payload);
if (msg && msg->type == MessageType::NODE_STATUS) {
    NodeStatusMessage* statusMsg = static_cast<NodeStatusMessage*>(msg);
    // ... use statusMsg ...
    delete msg;
}
```

to:
```cpp
EspNowMessage* msg = MessageFactory::createMessage(payload);
if (msg) {
    if (msg->type == MessageType::NODE_STATUS) {
        NodeStatusMessage* statusMsg = static_cast<NodeStatusMessage*>(msg);
        // ... use statusMsg ...
    }
    delete msg;
}
```

**Step 2: Fix TOWER_TELEMETRY block (lines 547-578)**

Same pattern: move `delete msg;` outside the type-check `if`, inside the null-check `if`.

**Step 3: Fix TOWER_JOIN_REQUEST block (lines 584-635)**

Same pattern: move `delete msg;` outside the type-check `if`, inside the null-check `if`.

**Step 4: Fix Coordinator::handlePairingRequest (lines 262-340)**

In `Coordinator.cpp`, the `handlePairingRequest` method has the same leak pattern:
```cpp
EspNowMessage* msg = MessageFactory::createMessage(payload);
if (msg && msg->type == MessageType::JOIN_REQUEST) {
    // ... long block ...
    delete msg;
}
```

Change to:
```cpp
EspNowMessage* msg = MessageFactory::createMessage(payload);
if (msg) {
    if (msg->type == MessageType::JOIN_REQUEST) {
        // ... long block ...
    }
    delete msg;
}
```

**Step 5: Verify firmware compiles**

Run: `pio run -e coordinator` (from Firmware/coordinator/)

**Step 6: Commit**

```bash
git add Firmware/coordinator/src/core/Reservoir.cpp Firmware/coordinator/src/core/Coordinator.cpp
git commit -m "fix(firmware): prevent memory leaks from MessageFactory on type mismatch (#77)"
```

---

## Task 18: Final verification build

**Step 1: Build all targets**

Backend: `dotnet build Backend/src/IoT.Backend/`
Frontend: `npx ng build` (from Frontend/IOT-Frontend-main/)
Coordinator firmware: `pio run -e coordinator` (from Firmware/coordinator/)
Node firmware: `pio run -e node` (from Firmware/node/)

**Step 2: Run backend tests**

Run: `dotnet test Backend/tests/IoT.Backend.UnitTests/`
Expected: All tests pass

**Step 3: Squash or leave as individual commits per user preference**
